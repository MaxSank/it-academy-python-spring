"""Шоколадка **
Определения:
1. Шоколадка - прямоугольник,
размером n×m (n, m - натуральные).
2. Разлом - деление шоколадки на
две части с натуральными размерами
по прямой.
3. Долька - элемент шоколадки
размером 1х1. Очевидно шоколадка
состоит из n*m долек.
4. Кусок - элемент шоколадки
произвольного (целочисленного размера).


1. Определите, можно ли одним разломом
отделить от шоколадки кусок площадью
ровно k.
2. Определите, можно ли отломить от шоколадки ровно
k долек за некоторое количество разломов.
3. Определите, можно ли отломить от шоколадки ровно
k долек размера с помощью t разломов
Описание решения поместите в docstring
"""

"""
1. Условие:
Определите, можно ли одним разломом
отделить от шоколадки кусок площадью
ровно k.

В первой задаче нам надо сначала
убедиться, что в принципе можно выполнить
разлом. Если будет требование
отломить кусок, который больше или равен
площади шоколадки, то выполнить разлом
будет невозможно.
Т.к. отломить надо за один раз, то
одна из сторон отломанной части k должна
быть равна или n или m. Значит, деление k на
n или m должно давать целое число.
"""


def first(n, m, k):
    if k < n * m:
        print(k % n == 0 or k % m == 0)
    else:
        print('Кусок больше возможного')


print('Первая задача:')
first(1, 8, 7)
first(2, 8, 4)
first(3, 5, 4)
first(1, 8, 8)

"""
2. Условие:
Определите, можно ли отломить
от шоколадки ровно k долек за
некоторое количество разломов.

Проверяем физическую можность отломать
кусок.

Отределяем большую и меньшую стороны.

В цикле:
1) проверяем возможность отломить
кусок за 1 раз.
2) если невозможно за 1 раз:
2.1) если кусок больше, чем большая
сторона, рассматриваем два варианта отломить
за 1 раз максимально возможный кусок,
меньший k.
В первом проверяем, не получится ли в
результате отлома, параллельного меньшей
стороне такой остаток, который из-за
уменьшения большей стороны будет равен
её новому размеру. Если да, то уменьшаем
большую сторону результат целочисленного
деления k на меньшую сторону, k приравниваем
к остатку деления.
Второй выполняется во всех прочих случаях.
Здесь отлом идёт параллельно меньшей стороне,
меньшая сторона уменьшается на значение
целочисленного деления k а большую сторону,
k приравнивается к остатку деления.
Возможность отломить k от уменьшившейся
меньшей стороны будет проверена в пункте 1.
Возвращаемся к пункту 1.
2.2) если кусок меньше, чем большая сторона,
и не ломается за 1 раз от меньшей (см. п. 1),
то возможен единственный вариант: отломать его
за 2 разлома.
"""


def second(n, m, k):
    if k < n * m:

        big_side = max([n, m])
        lit_side = min([n, m])
        razl = 0

        while k > 0:
            if not k % big_side or not k % lit_side:
                razl += 1
                k = 0
            else:

                if k > big_side:
                    razl += 1
                    if k % lit_side == (big_side - k // lit_side):
                        k, big_side = (k % lit_side), (big_side - (k // lit_side))
                    else:
                        k, lit_side = (k % big_side), (lit_side - (k // big_side))
                else:
                    razl += 2
                    k = 0
        print("Минимальное количество разломов:", razl)

    else:
        print('Кусок больше возможного')


print('\nВторая задача:')
second(3, 5, 6)  # сразу отламываем от одной стороны
second(3, 5, 10)  # сразу отламываем от другой стороны
second(3, 5, 7)  # сначала отламываем от большей стороны, остаток отламываем от меньшей за 1 раз
second(4, 5, 11)  # сначала отламываем от меньшей стороны, остаток отламываем от "большей" за 1 раз
second(3, 5, 8)  # все прочие случаи: максимально возможное число разломов
second(3, 5, 16)  # неверно указан размер k
